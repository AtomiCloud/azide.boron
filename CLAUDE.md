# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Azide Boron is a **Progressive Web App (PWA)** built as a pure static Astro site configured for deployment to Cloudflare Workers using Wrangler's static assets feature. The project uses Bun as its JavaScript runtime and package manager, Nix flakes for development environment management, and features a hierarchical configuration system with YAML files and environment variables.

## Common Commands

### Development

- `bun run dev` - Start Astro development server (PWA enabled in dev mode)
- `bun run build` - Build the Astro project for production
- `bun run preview` - Preview the production build locally
- `bun run generate-pwa-assets` - Regenerate PWA icons/favicons from source logo

### Using pls (Taskfile superset)

The project uses `pls` (a superset of Task) for task automation:

- `pls setup` - Install dependencies with `bun install`
- `pls dev` - Start Astro development server
- `pls build` - Build the static Astro project
- `pls preview` - Build and start local wrangler dev server (landscape: lapras)
- `pls upload -- <landscape>` - Build and upload new version without deploying (e.g., `pls upload -- pichu`)
- `pls deploy -- <landscape>` - Build and deploy to landscape (e.g., `pls deploy -- pikachu`)

### Cloudflare Workers Deployment

The project is configured for Cloudflare Workers deployment with environment-specific configurations:

- **lapras**: Development environment
- **pichu**: Production environment
- **pikachu**: Production environment
- **raichu**: Production environment

**Deployment workflows:**

- Local preview: `pls preview` (builds + runs wrangler dev on http://localhost:8787)
- Version upload: `pls upload -- <landscape>` (creates new version without deploying)
- Full deployment: `pls deploy -- <landscape>` (builds + deploys immediately)
- Manual: `bun run build && npx wrangler deploy --env <landscape>`

## Architecture

### Technology Stack

- **Framework**: Astro 5.15.1 (Static Site Generation)
- **UI Components**: React with shadcn/ui (Tailwind CSS + Radix UI)
- **Styling**: Tailwind CSS v3 with dark mode support
- **PWA**: @vite-pwa/astro with Workbox for service worker
- **SEO**: @astrojs/sitemap for automatic sitemap generation
- **OG Images**: Satori (JSX to SVG) + Sharp (SVG to PNG)
- **Configuration**: Hierarchical YAML + environment variables (js-yaml)
- **Runtime**: Bun (specified as dev dependency with TypeScript 5 peer dependency)
- **Deployment**: Cloudflare Workers via wrangler
- **Development Environment**: Nix flakes with NixOS 25.05

### Project Structure

- `src/` - Source code
  - `pages/` - Astro pages
    - `index.astro` - Homepage with blog list, search, and filters
    - `blog/` - Blog post pages (custom HTML/CSS with shadcn components)
    - `og-image.png.ts` - Default Open Graph image API route
    - `rss.xml.ts` - RSS feed generator
  - `layouts/` - Layout components
    - `Layout.astro` - Base layout with SEO, PWA, and theme support
    - `BlogPostLayout.astro` - Reusable blog post layout
  - `components/` - Reusable components
    - `SEO.astro` - SEO meta tags component
    - `ThemeToggle.tsx` - Dark/light theme toggle button
    - `PWAInstallButton.tsx` - PWA installation prompt
    - `ui/` - shadcn/ui components (Button, Card, Badge)
  - `lib/` - Utility libraries
    - `config.ts` - Hierarchical configuration loader
    - `blog-posts.ts` - Blog post data structure and helpers
    - `generate-og-image.ts` - OG image generation using Satori and Sharp
    - `og-template-simple.tsx` - Reusable OG image template (React/JSX)
    - `utils.ts` - Utility functions (cn for class merging)
  - `styles/` - Global styles
    - `globals.css` - Tailwind directives and theme CSS variables
- `public/` - Static assets served directly
  - `pwa-assets/` - Source logo (logo.svg) for PWA asset generation
  - PWA icons (auto-generated, gitignored): favicon.ico, pwa-\*.png, apple-touch-icon, maskable-icon
  - `robots.txt` - SEO robots file with sitemap reference
- `config.yaml` - Base configuration
- `config.<landscape>.yaml` - Landscape-specific config overrides (lapras, pichu, pikachu, raichu)
- `pwa-assets.config.ts` - PWA assets generator configuration
- `dist/` - Built output directory (generated by `bun run build`)
- `nix/` - Nix configuration files for development environment
- `scripts/ci/` - CI deployment scripts:
  - `export_build_info.sh` - Exports build metadata as environment variables
  - `upload.sh` - Handles both upload and deploy workflows
- `scripts/local/` - Local development scripts:
  - `preview.sh` - Local preview with wrangler dev

### Deployment Configuration

The `wrangler.toml` defines:

- Static assets served from `./dist` directory (Astro's build output)
- **No worker binding** - pure static asset serving (bindings only work with worker scripts)
- Observability enabled with 100% head sampling
- Environment-specific configurations with landscape-based naming (lapras/pichu/pikachu/raichu)
- Each environment has a `LANDSCAPE` environment variable

### Build Info System

The deployment scripts (`scripts/ci/export_build_info.sh`) automatically inject build metadata:

- `ATOMI_COMMON__APP__BUILD__SHA` - Git commit SHA (e.g., "sha-a9aa0ec")
- `ATOMI_COMMON__APP__BUILD__VERSION` - Git tag version or "unknown"
- `ATOMI_COMMON__APP__BUILD__TIME` - Build timestamp in milliseconds
- `ATOMI_COMMON__APP__SERVICETREE__LANDSCAPE` - Deployment landscape
- `LANDSCAPE` - Environment identifier (lapras/pichu/pikachu/raichu)

These are exported as environment variables during the build process for both local preview and CI deployments.

### Hierarchical Configuration System

The project uses a three-tier configuration hierarchy:

1. **Base Config** (`config.yaml`) - Default values for all environments
2. **Landscape Config** (`config.<landscape>.yaml`) - Environment-specific overrides
3. **Environment Variables** - Runtime overrides with `ATOMI__` prefix

**Configuration loading order:**

```
config.yaml → config.<landscape>.yaml → ATOMI__* env vars
```

**Environment variable mapping:**

- Use `ATOMI__` prefix (double underscore after ATOMI)
- Use `__` as delimiter for nested properties
- Example: `ATOMI__APP__NAME="My App"` → `config.app.name`
- Example: `ATOMI__SEO__DEFAULT_TITLE="Title"` → `config.seo.defaultTitle`

**Available configuration:**

- `app.*` - Application metadata (name, shortName, description, themeColor, backgroundColor)
- `theme.*` - Theme colors:
  - `theme.primary` - Single primary brand color (affects buttons, links, focus rings throughout the site)
  - `theme.gradientStart` - Gradient start color (used in OG images)
  - `theme.gradientEnd` - Gradient end color (used in OG images)
  - `theme.blog.*` - Topic-specific color overrides for blog posts (tech, marketing, entrepreneurship, productivity, health)
- `seo.*` - SEO settings (defaultTitle, titleTemplate, defaultDescription, siteName, locale, type)
- `site.*` - Site settings (url, author)
- `social.*` - Social media handles (twitter, github)

**Usage:**

```typescript
import { getConfig } from '../lib/config';
const config = getConfig(); // Returns typed Config object
```

The configuration is automatically loaded in `astro.config.mjs` and respects the `LANDSCAPE` environment variable.

**Color System:**

The theme uses a single primary color (`theme.primary`) that affects all interactive elements (buttons, links, focus rings) throughout the site. The color is automatically converted from hex to HSL and injected as CSS custom properties in `Layout.astro`. To change the site's primary color, simply update `theme.primary` in `config.yaml` - no CSS changes needed.

### Progressive Web App (PWA) Features

**PWA Configuration:**

- Service Worker with Workbox for offline caching
- Auto-update strategy (no manual refresh required)
- Web App Manifest with dynamic config from YAML
- Install prompt with native UI
- Offline support for all static assets
- Runtime caching for external resources (Google Fonts)

**PWA Assets:**

- Single source logo: `public/pwa-assets/logo.svg`
- Auto-generated assets (via `bun run generate-pwa-assets`):
  - `favicon.ico` - Browser favicon
  - `apple-touch-icon-180x180.png` - iOS home screen icon
  - `pwa-64x64.png`, `pwa-192x192.png`, `pwa-512x512.png` - PWA icons
  - `maskable-icon-512x512.png` - Maskable icon for Android adaptive icons
- Generated assets are **gitignored** and should be regenerated when logo changes

**Install Experience:**

- Users can install the app to their home screen
- Works on iOS, Android, and desktop browsers
- Install button appears automatically when installable
- Standalone app-like experience when installed

### SEO Optimization

**Implemented SEO features:**

- Automatic sitemap generation via `@astrojs/sitemap`
- `robots.txt` with sitemap reference
- Canonical URLs for all pages
- Open Graph tags (Facebook, LinkedIn)
- Twitter Card tags
- Meta descriptions and titles
- Structured SEO component for reusability
- Image optimization with responsive sizing

**SEO Component Usage:**

```astro
<Layout
  title="Page Title"
  description="Page description"
  image="/custom-og-image.png"
  article={false}
  noindex={false}
/>
```

### Open Graph Image Generation

The project uses **Satori** (by Vercel) to generate beautiful Open Graph images at build time. Satori converts JSX/React components to SVG, which is then converted to PNG using Sharp.

**Generated OG Images:**

- Default site OG image: `/og-image.png` (1200x630px, auto-generated at build time)
- Custom page OG images: Create additional API routes in `src/pages/` (e.g., `src/pages/blog/[slug]/og.png.ts`)

**OG Image Framework:**

The project includes a reusable OG image template with the following customizable fields:

```typescript
interface OgImageProps {
  title: string; // Required: Main title text
  subtitle?: string; // Optional: Subtitle/description
  author?: string; // Optional: Author name
  siteName?: string; // Optional: Site name (default: 'Azide Boron')
  themeColor?: string; // Optional: Brand color (default: '#4F46E5')
}
```

**Template Features:**

- 1200x630px dimensions (standard OG image size)
- Gradient background with customizable theme color
- White card with shadow effect
- Logo placeholder (letter "B" in colored square)
- Responsive font sizing based on title length
- Professional footer with author/date and theme indicator

**Creating Custom OG Images:**

To create a custom OG image for a specific page:

1. Create an API route in `src/pages/` (e.g., `src/pages/custom-og.png.ts`):

```typescript
import type { APIRoute } from 'astro';
import { generateOgImage } from '../lib/generate-og-image';

export const GET: APIRoute = async () => {
  const png = await generateOgImage({
    title: 'Your Custom Title',
    subtitle: 'Optional subtitle',
    author: 'Author Name',
    themeColor: '#4F46E5',
  });

  return new Response(png, {
    headers: {
      'Content-Type': 'image/png',
      'Cache-Control': 'public, max-age=31536000, immutable',
    },
  });
};
```

2. Reference the image in your SEO component:

```astro
<Layout
  title="Custom Page"
  description="Description"
  image="/custom-og.png"
/>
```

**Font Loading:**

The OG image generator loads Google Fonts (Inter 400 and 800) dynamically at build time. Fonts are cached after the first load for better performance.

**Modifying the Template:**

To customize the OG image design:

1. Edit `src/lib/og-template-simple.tsx` (or create a new template)
2. **Important:** Satori requires ALL parent divs with multiple children to have explicit `display: flex`, `display: contents`, or `display: none`
3. Avoid conditional rendering - use empty strings instead
4. Test with `bun run build` to verify the template works

**Build Process:**

- OG images are generated at build time, not runtime
- Generated images are included in the static `dist/` output
- Images are automatically precached by the PWA service worker
- Build time for OG images: ~500ms per image

### TypeScript Configuration

- Extends Astro's base tsconfig
- Strict mode enabled with ESNext target
- Bundler module resolution
- noUncheckedIndexedAccess enabled for safer array/object access
- noUnusedLocals and noUnusedParameters disabled

### UI Components and Theming

**Dark Mode Support:**

The project includes a fully functional dark/light theme system with the following features:

- **Theme Toggle Component** (`src/components/ThemeToggle.tsx`) - React component that switches between light and dark themes
- **Persistent Theme** - User's theme preference is saved to `localStorage` and persists across sessions
- **System Preference Detection** - Falls back to system color scheme preference if no saved theme exists
- **No Flash of Unstyled Content** - Theme is applied before page renders using an inline script in `Layout.astro`
- **Tailwind Dark Mode** - Uses `darkMode: ['class']` strategy in `tailwind.config.mjs`

**IMPORTANT: All new components MUST support both light and dark themes.**

When creating or modifying components, always ensure they work in both themes by:

1. **Using Tailwind's dark mode classes:**

   ```tsx
   // Good - responsive to theme
   <div className="bg-background text-foreground dark:bg-background dark:text-foreground">

   // Better - use semantic color tokens that automatically adapt
   <div className="bg-background text-foreground">
   ```

2. **Using semantic color tokens from the theme:**

   - `background`, `foreground` - Main background and text
   - `card`, `card-foreground` - Card backgrounds
   - `primary`, `primary-foreground` - Primary brand colors
   - `secondary`, `secondary-foreground` - Secondary colors
   - `muted`, `muted-foreground` - Muted/subdued colors
   - `accent`, `accent-foreground` - Accent highlights
   - `destructive`, `destructive-foreground` - Error/danger states
   - `border` - Border colors
   - `input` - Input field backgrounds
   - `ring` - Focus ring colors

3. **Testing in both themes:**
   - Always test components in both light and dark modes
   - Use the theme toggle in the top-right corner to switch themes
   - Verify readability, contrast, and visual hierarchy in both modes

**shadcn/ui Components:**

The project uses shadcn/ui components built with Tailwind CSS and Radix UI:

- `src/components/ui/button.tsx` - Button with variants (default, destructive, outline, secondary, ghost, link)
- `src/components/ui/card.tsx` - Card components (Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter)
- `src/components/ui/badge.tsx` - Badge component for tags and labels

All shadcn components automatically support dark mode through the semantic color system.

**PWA Install Button:**

- `src/components/PWAInstallButton.tsx` - Prompts users to install the PWA
- Only shows when the app is installable (not already installed or in standalone mode)
- Automatically hides after installation
- Uses the `beforeinstallprompt` event API

**Creating New Components:**

When creating new React components:

1. Place them in `src/components/` or `src/components/ui/` for reusable UI primitives
2. Use TypeScript for type safety
3. Support both light and dark themes using semantic color tokens
4. Use the `client:load` directive when importing into Astro pages
5. Follow shadcn/ui patterns for consistency

Example:

```tsx
// src/components/MyComponent.tsx
import React from 'react';
import { cn } from '../lib/utils';

export function MyComponent({ className }: { className?: string }) {
  return (
    <div className={cn('bg-card text-card-foreground rounded-lg p-4', className)}>
      Content that works in both themes
    </div>
  );
}
```

```astro
---
import { MyComponent } from '../components/MyComponent';
---
<MyComponent client:load />
```

### Development Environment (Nix)

The project uses Nix flakes for reproducible development environments with:

- Bun for JavaScript runtime
- Git, infisical for secrets management
- Formatting tools: treefmt, biome, prettier
- Linting: gitlint, shellcheck
- AtomiCloud utilities (sg, pls, atomiutils)

## Important Notes

### Pure Static Site

This is a **pure static site** - no SSR adapter is used. Astro builds to static HTML/CSS/JS files that are served directly from Cloudflare Workers using the static assets feature.

**Critical:** The `wrangler.toml` must NOT include `binding = "ASSETS"` in the `[assets]` section. Bindings are only for Workers with scripts (`main` entry point). Static-only deployments will fail with "Cannot use assets with a binding in an assets-only Worker" if a binding is present.

### Image Handling

For static sites, Astro's built-in image optimization works during build time:

- Images in `src/` are processed and optimized by Astro's `<Image />` component
- Images in `public/` directory are copied as-is without optimization
- The `experimentalResponsiveImages` flag is enabled in `astro.config.mjs` for automatic responsive sizing
- Remote images require domain authorization in the config

### PWA Asset Generation

**Important:** PWA assets (favicons, app icons) are auto-generated from a single source logo and should NOT be committed to git.

**To update PWA icons:**

1. Replace `public/pwa-assets/logo.svg` with your new logo
2. Run `bun run generate-pwa-assets`
3. Assets will be generated in `public/` directory
4. The generated files are automatically gitignored

**Source logo requirements:**

- Format: SVG (recommended) or high-resolution PNG
- Size: 512x512px or larger
- Design: Simple, works well at small sizes
- For maskable icons: Keep important content in center "safe zone"

### Deployment Workflow Details

**Local Preview (`pls preview`):**

1. Exports build metadata via `scripts/ci/export_build_info.sh`
2. Runs `bun run build` to generate static files in `./dist`
3. Starts `wrangler dev --env lapras` on http://localhost:8787

**Upload (`pls upload -- <landscape>`):**

1. Installs dependencies with `bun install --ci`
2. Exports build metadata (commit SHA, version, timestamp)
3. Builds the project
4. Runs `wrangler versions upload --env <landscape>` (creates version without deploying)
5. Optionally includes release tag in upload message

**Deploy (`pls deploy -- <landscape>`):**

1. Same build process as upload
2. Runs `wrangler deploy --env <landscape>` (immediate deployment)

### Environment Variables

Each environment (lapras/pichu/pikachu/raichu) has a `LANDSCAPE` variable to identify the deployment environment. Build metadata is automatically injected during all deployment workflows.

- never run `pls dev` yourself, the user will always run the server
- Not start the development server with pls dev since the user users will run it themselves. We can assume that the server is already running at localhost:4321 at any time.
